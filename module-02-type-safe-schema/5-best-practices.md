# 5. Best Practices for Type Organization

Organize your types for maintainability, scalability, and team collaboration.

---

## File Structure for Types

### Recommended Structure

```
src/
├── generated/
│   └── graphql.ts              # Auto-generated by codegen (git ignored)
│
├── types/
│   ├── index.ts                # Barrel export
│   ├── context.ts              # Context interface
│   ├── scalars.ts              # Custom scalar types
│   └── models/                 # Database/domain models
│       ├── index.ts
│       ├── user.ts
│       └── post.ts
│
├── schema/
│   ├── typeDefs.ts             # GraphQL SDL
│   └── index.ts                # Schema composition
│
├── resolvers/
│   ├── index.ts                # Resolver composition
│   ├── Query.ts
│   ├── Mutation.ts
│   └── types/                  # Type resolvers
│       ├── User.ts
│       └── Post.ts
│
└── index.ts
```

---

## Separating Generated vs Manual Types

### Generated Types (Don't Edit!)

```typescript
// src/generated/graphql.ts
// ⚠️ AUTO-GENERATED - DO NOT EDIT

export type User = {
  __typename?: 'User';
  id: string;
  name: string;
  email: string;
  posts: Array<Post>;
};

export type Resolvers<ContextType = any> = {
  Query?: QueryResolvers<ContextType>;
  // ...
};
```

### Manual Types (Your Domain)

```typescript
// src/types/models/user.ts
// ✅ Your domain model - edit freely

export interface UserModel {
  id: string;
  name: string;
  email: string;
  passwordHash: string; // Not exposed in GraphQL
  role: UserRole;
  createdAt: Date;
  updatedAt: Date;
}

export type UserRole = 'ADMIN' | 'USER' | 'GUEST';

export interface CreateUserData {
  name: string;
  email: string;
  password: string;
  role?: UserRole;
}
```

### Context Type (Manual)

```typescript
// src/types/context.ts
import type { UserModel } from './models/user.js';

export interface Context {
  // Authentication
  currentUser: UserModel | null;

  // Services
  userService: UserService;
  postService: PostService;

  // Database
  db: Database;

  // Request
  request: Request;
}
```

---

## Domain-Driven Type Organization

Organize by domain/feature, not by technical layer:

### By Domain (Recommended)

```
src/
├── modules/
│   ├── user/
│   │   ├── user.types.ts       # User-related types
│   │   ├── user.schema.ts      # User GraphQL schema
│   │   ├── user.resolvers.ts   # User resolvers
│   │   ├── user.service.ts     # User business logic
│   │   └── index.ts
│   │
│   ├── post/
│   │   ├── post.types.ts
│   │   ├── post.schema.ts
│   │   ├── post.resolvers.ts
│   │   ├── post.service.ts
│   │   └── index.ts
│   │
│   └── auth/
│       ├── auth.types.ts
│       ├── auth.schema.ts
│       ├── auth.resolvers.ts
│       ├── auth.service.ts
│       └── index.ts
│
├── shared/
│   ├── types/
│   │   ├── context.ts
│   │   └── scalars.ts
│   └── utils/
│
└── generated/
    └── graphql.ts
```

### Module Example

```typescript
// src/modules/user/user.types.ts
export interface UserModel {
  id: string;
  name: string;
  email: string;
  passwordHash: string;
  role: UserRole;
  createdAt: Date;
}

export type UserRole = 'ADMIN' | 'USER';

export interface CreateUserInput {
  name: string;
  email: string;
  password: string;
}

export interface UpdateUserInput {
  name?: string;
  email?: string;
}

export interface UserFilters {
  role?: UserRole;
  search?: string;
}
```

```typescript
// src/modules/user/user.schema.ts
export const userTypeDefs = /* GraphQL */ `
  type User {
    id: ID!
    name: String!
    email: String!
    role: UserRole!
    posts: [Post!]!
    createdAt: DateTime!
  }

  enum UserRole {
    ADMIN
    USER
  }

  input CreateUserInput {
    name: String!
    email: String!
    password: String!
  }

  extend type Query {
    me: User
    user(id: ID!): User
    users(filters: UserFilters): [User!]!
  }

  extend type Mutation {
    createUser(input: CreateUserInput!): User!
    updateUser(id: ID!, input: UpdateUserInput!): User!
  }
`;
```

```typescript
// src/modules/user/user.resolvers.ts
import type { Resolvers } from '../../generated/graphql.js';
import type { UserModel } from './user.types.js';

export const userResolvers: Resolvers = {
  Query: {
    me: (_, __, context) => context.currentUser,
    user: (_, args, context) => context.userService.findById(args.id),
    users: (_, args, context) => context.userService.findAll(args.filters),
  },

  Mutation: {
    createUser: (_, args, context) => context.userService.create(args.input),
    updateUser: (_, args, context) => context.userService.update(args.id, args.input),
  },

  User: {
    posts: (parent, _, context) => context.postService.findByAuthorId(parent.id),
  },
};
```

```typescript
// src/modules/user/index.ts
export * from './user.types.js';
export { userTypeDefs } from './user.schema.js';
export { userResolvers } from './user.resolvers.js';
```

---

## Barrel Exports

Use index files to create clean import paths:

### Types Barrel

```typescript
// src/types/index.ts
export * from './context.js';
export * from './scalars.js';
export * from './models/index.js';
```

```typescript
// src/types/models/index.ts
export * from './user.js';
export * from './post.js';
export * from './comment.js';
```

### Usage

```typescript
// Clean imports
import type { Context, UserModel, PostModel } from '../types/index.js';

// Instead of
import type { Context } from '../types/context.js';
import type { UserModel } from '../types/models/user.js';
import type { PostModel } from '../types/models/post.js';
```

### Schema Barrel

```typescript
// src/schema/index.ts
import { createSchema } from 'graphql-yoga';
import { mergeTypeDefs, mergeResolvers } from '@graphql-tools/merge';

import { baseTypeDefs } from './base.js';
import { userTypeDefs, userResolvers } from '../modules/user/index.js';
import { postTypeDefs, postResolvers } from '../modules/post/index.js';
import { authTypeDefs, authResolvers } from '../modules/auth/index.js';

const typeDefs = mergeTypeDefs([baseTypeDefs, userTypeDefs, postTypeDefs, authTypeDefs]);

const resolvers = mergeResolvers([userResolvers, postResolvers, authResolvers]);

export const schema = createSchema({ typeDefs, resolvers });
```

---

## Avoiding Circular Dependencies

Circular dependencies cause runtime errors and confuse TypeScript.

### Problem: Circular Import

```typescript
// ❌ user.ts imports post.ts
import type { Post } from './post.js';

export interface User {
  id: string;
  posts: Post[];
}

// ❌ post.ts imports user.ts
import type { User } from './user.js';

export interface Post {
  id: string;
  author: User; // Circular!
}
```

### Solution 1: Use Type-Only Imports

```typescript
// ✅ Type-only imports don't cause circular issues at runtime
import type { Post } from './post.js';
import type { User } from './user.js';
```

### Solution 2: Shared Types File

```typescript
// src/types/models/shared.ts
export interface User {
  id: string;
  name: string;
  email: string;
}

export interface Post {
  id: string;
  title: string;
  authorId: string; // Reference by ID, not object
}

// Relationships resolved in resolvers, not types
```

### Solution 3: Lazy Type References

```typescript
// src/types/models/user.ts
export interface User {
  id: string;
  name: string;
  // Don't include posts here - resolve in GraphQL layer
}

// src/types/models/post.ts
export interface Post {
  id: string;
  title: string;
  authorId: string; // Just the ID
  // author resolved in GraphQL layer
}
```

---

## Type Naming Conventions

### Consistent Naming

| Type            | Convention         | Example                  |
| --------------- | ------------------ | ------------------------ |
| GraphQL types   | PascalCase         | `User`, `Post`           |
| Database models | PascalCase + Model | `UserModel`, `PostModel` |
| Input types     | PascalCase + Input | `CreateUserInput`        |
| Args types      | PascalCase + Args  | `UserQueryArgs`          |
| Enums           | PascalCase         | `UserRole`, `PostStatus` |
| Context         | Context            | `Context`                |

### Examples

```typescript
// GraphQL types (from codegen)
export type User = { ... };
export type Post = { ... };

// Database models
export interface UserModel { ... }
export interface PostModel { ... }

// Input types
export interface CreateUserInput { ... }
export interface UpdateUserInput { ... }

// Query/Mutation args
export interface GetUserArgs { id: string; }
export interface CreateUserArgs { input: CreateUserInput; }

// Enums
export type UserRole = 'ADMIN' | 'USER';
export type PostStatus = 'DRAFT' | 'PUBLISHED';
```

---

## Re-exporting Generated Types

Create a clean API for your generated types:

```typescript
// src/types/graphql.ts
// Re-export only what you need from generated types

export type {
  // Object types
  User,
  Post,
  Comment,

  // Input types
  CreateUserInput,
  UpdateUserInput,
  CreatePostInput,

  // Enums
  UserRole,
  PostStatus,

  // Resolver types
  Resolvers,
  QueryResolvers,
  MutationResolvers,
} from '../generated/graphql.js';
```

### Usage

```typescript
// Clean import from your types
import type { User, Resolvers } from '../types/graphql.js';

// Instead of
import type { User, Resolvers } from '../generated/graphql.js';
```

---

## Type Documentation

Document complex types with JSDoc:

```typescript
/**
 * Represents a user in the system.
 *
 * @example
 * const user: UserModel = {
 *   id: '123',
 *   name: 'John Doe',
 *   email: 'john@example.com',
 *   role: 'USER',
 *   createdAt: new Date(),
 * };
 */
export interface UserModel {
  /** Unique identifier (UUID) */
  id: string;

  /** User's display name */
  name: string;

  /** User's email address (unique) */
  email: string;

  /** Hashed password (never exposed via API) */
  passwordHash: string;

  /** User's role for authorization */
  role: UserRole;

  /** Account creation timestamp */
  createdAt: Date;
}

/**
 * User roles for authorization.
 * - ADMIN: Full access to all resources
 * - USER: Standard user access
 * - GUEST: Read-only access
 */
export type UserRole = 'ADMIN' | 'USER' | 'GUEST';
```

---

## Checklist: Type Organization

- [ ] Generated types in `src/generated/` (git ignored)
- [ ] Manual types in `src/types/`
- [ ] Context type in `src/types/context.ts`
- [ ] Domain models in `src/types/models/`
- [ ] Barrel exports for clean imports
- [ ] No circular dependencies
- [ ] Consistent naming conventions
- [ ] JSDoc for complex types
- [ ] Re-export generated types through your own module

---

## Summary

| Practice                  | Benefit                              |
| ------------------------- | ------------------------------------ |
| Separate generated/manual | Clear ownership, no accidental edits |
| Domain-driven structure   | Scalable, team-friendly              |
| Barrel exports            | Clean imports                        |
| Avoid circular deps       | No runtime errors                    |
| Consistent naming         | Predictable codebase                 |
| Document types            | Self-documenting code                |

---

## Module 02 Complete!

You now know how to:

- ✅ Map GraphQL types to TypeScript
- ✅ Write type-safe resolvers
- ✅ Use GraphQL Code Generator
- ✅ Organize types for large projects

---

## Next Module: [Module 03 - Database Integration →](../module-03-database/README.md)
